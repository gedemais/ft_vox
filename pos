src/init/uniforms.c:7:	glUniform3fv(env->model.uniforms.light[LIGHT_SOURCE_PLAYER][LIGHT_POSITION], 1, (GLfloat *)&env->light.sources[LIGHT_SOURCE_PLAYER].pos);
src/init/uniforms.c:12:	env->light.sources[LIGHT_SOURCE_SUN].pos = mat4_x_vec3(m, env->light.sources[LIGHT_SOURCE_SUN].base_pos);
src/init/uniforms.c:13:	glUniform3fv(env->model.uniforms.light[LIGHT_SOURCE_SUN][LIGHT_POSITION], 1, (GLfloat *)&env->light.sources[LIGHT_SOURCE_SUN].pos);
src/init/uniforms.c:15:	env->light.sources[LIGHT_SOURCE_SUN].dir = vec_add(env->light.sources[LIGHT_SOURCE_SUN].pos, env->model.center);
src/init/uniforms.c:37:	mat4_translate(m, env->camera.pos.x, env->camera.pos.y, env->camera.pos.z);
src/init/uniforms.c:53:			// update campos
src/init/uniforms.c:54:			glUniform3fv(env->model.uniforms.campos, 1, (GLfloat *)&env->camera.pos);
src/init/uniforms.c:102:			// campos
src/init/uniforms.c:103:			env->model.uniforms.campos = glGetUniformLocation(program, "campos");
src/init/meshs.c:5:	// id ptr, size, GL_type, GL_FALSE, totalsize, start pos
src/init/meshs.c:31:	// Specifies the disposition of components in vertexs
src/init/camera.c:12:	// Camera starting position and orientation
src/init/camera.c:13:	camera->pos = env->model.center;
src/init/camera.c:23:	env->mouse.pos.x = env->settings.w_wdt / 2;
src/init/camera.c:24:	env->mouse.pos.y = env->settings.w_hgt / 2;
src/init/init_world.c:91:	// camera before light because we need campos
src/init/light.c:17:	build_target(target, "].pos", ai);
src/init/light.c:55:		glUniform3fv(env->model.uniforms.light[i][LIGHT_POSITION], 1, (GLfloat *)&light->sources[i].pos);
src/init/light.c:70:	source->pos			= env->camera.pos;
src/init/light.c:90:	source->pos			= (vec3){ 0.85f, 0, -1 };
src/init/light.c:91:	source->pos			= (vec3){ source->pos.x * e, 16, source->pos.z * e };
src/init/light.c:92:	source->base_pos	= source->pos;
src/init/light.c:93:	source->dir			= vec_add(source->pos, env->model.center);
src/init/textures.c:41:	// depthmap at last position
src/render.c:13:		env->light.sources[i].pos,
src/render.c:14:		vec_add(env->light.sources[i].pos, env->light.sources[i].dir),
src/render.c:104:		camera->pos.y = 0;
src/render.c:105:	mat4_lookat(camera->view, camera->pos, vec_add(camera->pos, camera->zaxis), camera->yaxis);
src/render.c:137:	// we update the flaslight position
src/render.c:138:	env->light.sources[LIGHT_SOURCE_PLAYER].pos = env->camera.pos;
src/render.c:141:	env->light.sources[LIGHT_SOURCE_PLAYER].pos.y -= MODEL_SCALE / 2.0f;
src/render.c:183:		printf("%f %f %f\n", env->camera.pos.x, env->camera.pos.y, env->camera.pos.z);
src/actions/events.c:56:static void				cb_cursor_position(GLFWwindow *window, double xpos, double ypos)
src/actions/events.c:58:	glfwGetCursorPos(window, &xpos, &ypos);
src/actions/events.c:59:	events_mouse(g_env, (float)xpos, (float)ypos);
src/actions/events.c:100:	glfwSetCursorPosCallback(env->window.ptr, cb_cursor_position);
src/actions/live.c:14:		camera->pos = vec_add(camera->pos, vec_fmult(vec_cross(camera->zaxis, camera->yaxis), speed));
src/actions/live.c:16:		camera->pos = vec_sub(camera->pos, vec_fmult(vec_cross(camera->zaxis, camera->yaxis), speed));
src/actions/live.c:18:		camera->pos = vec_add(camera->pos, vec_fmult(camera->zaxis, speed));
src/actions/live.c:20:		camera->pos = vec_sub(camera->pos, vec_fmult(camera->zaxis, speed));
src/actions/live.c:22:		camera->pos = vec_add(camera->pos, vec_fmult(camera->yaxis, speed));
src/actions/live.c:24:		camera->pos = vec_sub(camera->pos, vec_fmult(camera->yaxis, speed));
src/actions/live.c:56:void		events_mouse(t_env *env, float xpos, float ypos)
src/actions/live.c:62:	xoffset = xpos - mouse->pos.x;
src/actions/live.c:63:	yoffset = mouse->pos.y - ypos;
src/actions/live.c:64:	mouse->pos.x = xpos;
src/actions/live.c:65:	mouse->pos.y = ypos;
src/shaders/depth_vertex.glsl:11:	vec4		pos;
src/shaders/depth_vertex.glsl:14:	pos.x = float(data1 & 0xFFFF);
src/shaders/depth_vertex.glsl:15:	pos.y = float((data1 & 0xFFFF0000) >> 16u);
src/shaders/depth_vertex.glsl:16:	pos.z = float(data2 & 0xFFFF);
src/shaders/depth_vertex.glsl:17:	pos.w = 1.0f;
src/shaders/depth_vertex.glsl:20:	gl_Position	= pos * view * projection;
src/shaders/skybox_vertex.glsl:13:	vec4	pos	= vec4(aPosition, 1) * model * view * projection;
src/shaders/skybox_vertex.glsl:18:	gl_Position	= pos.xyww;
src/shaders/fragment.glsl:6:	vec3	pos, dir, color;
src/shaders/fragment.glsl:23:uniform vec3			campos;
src/shaders/fragment.glsl:110:	e				= distance(source.pos, vPosition);
src/shaders/fragment.glsl:156:		vec3		view_dir	= normalize(campos - vPosition);
src/shaders/vertex.glsl:80:	vec4		pos;
src/shaders/vertex.glsl:85:	pos.x = float(data1 & 0xFFFF);
src/shaders/vertex.glsl:86:	pos.y = float((data1 & 0xFFFF0000) >> 16u);
src/shaders/vertex.glsl:87:	pos.z = float(data2 & 0xFFFF);
src/shaders/vertex.glsl:88:	pos.w = 1.0f;
src/shaders/vertex.glsl:103:		pos.y		+= (sin(pos.x * time) * cos(pos.y * time)) * wavelength + 0.5f;
src/shaders/vertex.glsl:108:	vPosition	= vec3(pos);
src/shaders/vertex.glsl:111:	vShadCoordP	= pos * dvp * dpp;
src/shaders/vertex.glsl:112:	vShadCoordS	= pos * dvs * dps;
src/shaders/vertex.glsl:114:	gl_Position	= pos * model * view * projection;
src/generation/update_world.c:241:static bool				check_player_presence(vec3 pos, t_chunk chunk)
src/generation/update_world.c:245:	x = pos.x > chunk.x_start && pos.x < chunk.x_start + CHUNK_SIZE;
src/generation/update_world.c:246:	z = pos.z > chunk.z_start && pos.z < chunk.z_start + CHUNK_SIZE;
src/generation/update_world.c:281:			if (check_player_presence(env->camera.pos, env->model.chunks[x][z])
